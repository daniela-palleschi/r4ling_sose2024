---
title: "Data Wrangling 2"
subtitle: "Data Tidying"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 9 - Data Tidying" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: wrangling2_blatt_DE.html
    include-after-body: ../../custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
    execute:
      fig-width: 6
      fig-asp: .618
  revealjs: 
    output-file: wrangling2_folien_DE.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: false
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
    execute:
      fig-width: 6
      fig-asp: .618
  pdf:
    output-file: wrangling2_DE.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
    execute:
      out-width: "70%"
      fig-asp: .618
bibliography: ../../references.bib
csl: ../../apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling2_EN.qmd")
```

# Lernziele {.unnumbered}

Heute werden wir lernen...

- √ºber breite versus lange Daten
- wie man breite Daten l√§nger macht
- wie man lange Daten breiter macht

## Ressourcen {.unnumbered}

Die vorgeschlagenen Ressourcen f√ºr dieses Thema sind

- [Kapitel 6 (Data Tidying)](https://r4ds.hadley.nz/data-tidy) in @wickham_r_2023
- [Kapitel 8 (Data Tidying)](https://psyteachr.github.io/ads-v2/08-tidy.html) in @nordmann_applied_2022

# Einrichtung

## Pakete

```{r}
pacman::p_load(tidyverse,
               here,
               janitor)
```

## Daten

- Wir verwenden den Datensatz `languageR_english.csv` (im Ordner `daten`)

```{r}
#| code-line-numbers: false
df_eng <- read_csv(here("daten", "languageR_english.csv")) |> 
  clean_names() |> #<1>
  arrange(word) |> #<2>
  rename( #<3>
    rt_lexdec = r_tlexdec, #<4>
    rt_naming = r_tnaming #<5>
  ) |> 
  select(age_subject, word, word_category, rt_lexdec, rt_naming) #<6>
```

1. Bereinigen (d.h. *tidy*) von Variablennamen (von `janitor`)
2. Zeilen nach `wort` in ansteigender Reihenfolge anordnen (A-Z)
3. Variablen umbenennen...
4. `r_tlexdec` in `rt_lexdec` umbenennen
5. `r_tlexdec` in `rt_lexdec` umbenennen
6. nur die genannten Spalten behalten

# 'Tidy' Arbeitsablauf

::: {.content-visible when-format="revealjs"}
- @fig-workflow-revealjs zeigt einen √úberblick √ºber den typischen Data-Science-Prozess
  + Wir importieren unsere Daten, bereinigen sie und durchlaufen dann einen Zyklus aus Umwandlung, Visualisierung und Modellierung, bevor wir schlie√ülich unsere Ergebnisse kommunizieren

```{r}
#| echo: false
#| out-width: "70%"
#| fig-align: center
#| label: fig-workflow-revealjs
#| fig-cap: "A model of the data science process from @wickham_r_2023 [(all rights reserved)](https://r4ds.hadley.nz/intro.html)"
magick::image_negate(magick::image_read(here::here("media/Wickham_tidyworkflow.png")))
```
:::

::: {.content-hidden when-format="revealjs"}
- @fig-workflow zeigt einen √úberblick √ºber den typischen Data-Science-Prozess
  + Wir importieren unsere Daten, bereinigen sie und durchlaufen dann einen Zyklus aus Umwandlung, Visualisierung und Modellierung, bevor wir schlie√ülich unsere Ergebnisse kommunizieren.

```{r}
#| echo: false
#| out-height: "100%"
#| label: fig-workflow
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/intro.html) @wickham_r_2023 (all rights reserved)"
magick::image_read(here::here("media/Wickham_tidyworkflow.png"))
```
:::

::: {.content-visible when-format="revealjs"}
## {.unlisted .unnumbered}
:::

- Bisher haben wir gelernt, wie man 
  + unsere Daten importieren (`readr::read_csv`)
  + Daten transformieren (Paket `dplyr`)
  + Daten zu visualisieren (Paket `ggplot`) 
  + unsere Ergebnisse mit dynamischen Berichten zu kommunizieren (Quarto)

- aber wir haben bis jetzt nur aufger√§umte Daten gesehen
  + daher mussten wir den Schritt des "tidy" (Paket `tidyr`) noch nicht durchf√ºhren

# 'Tidy' Daten

- dieselben Daten k√∂nnen auf verschiedene Weise dargestellt werden
- Wir werden uns 3 Tabellen ansehen, die genau dieselben Daten in verschiedenen Formaten darstellen
- Die Tabellen zeigen die gleichen Werte von vier Variablen: 
  + Land (`country`)
  + Jahr (`year`)
  + Bev√∂lkerung (`population`)
  + Anzahl der Tuberkulosef√§lle (`cases`)

- Jeder Datensatz ordnet die Werte anders an
- √ºberlegen Sie, welche Tabelle f√ºr Sie am einfachsten zu lesen ist

::: {.content-visible when-format="revealjs"}
##
:::: columns 
::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| label: tbl-1-revealjs
#| tbl-cap: Tabelle 1
df_tb <- read_csv(here("daten", "table1.csv"))
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 25
  )
```
:::

::: {.column width="33%"}
```{r}
#| output-location: fragment
#| echo: false
#| label: tbl-2-revealjs
#| tbl-cap: Tabelle 2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 24
  )
```
:::

::: {.column width="33%"}
```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
#| label: tbl-3-revealjs
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 25
  )
```
:::

:::: 

:::

::: {.content-hidden when-format="revealjs"}

```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 1
#| label: tbl-1
df_tb %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: Tabelle 2
#| label: tbl-2
df_tb %>%
  pivot_longer(
    cols = c(cases, population),
    names_to = "type",
    values_to = "count"
  ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20
  )
```

```{r}
#| echo: false
#| output-location: fragment
#| tbl-cap: Tabelle 3
#| label: tbl-3
df_tb %>%
  # group_by(country,year) %>% 
  mutate(rate = paste0(cases,"/",population)) %>% 
  select(-cases,-population) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(
    font_size = 20,
    full_width = F
  )
```

:::

## Regeln f√ºr 'tidy' Daten

::: {.content-visible when-format="revealjs"}
- Wahrscheinlich ist @tbl-1-revealjs f√ºr Sie am einfachsten zu lesen
  + sie folgt den drei Regeln f√ºr aufger√§umte Daten (visualisiert in @fig-tidy):
  
:::

::: {.content-hidden when-format="revealjs"}
- Wahrscheinlich ist @tbl-1 f√ºr Sie am einfachsten zu lesen
  + sie folgt den drei Regeln f√ºr aufger√§umte Daten (visualisiert in @fig-tidy):
:::

1.  Jede Variable ist eine Spalte, jede Spalte ist eine Variable
2.  Jede Beobachtung ist eine Zeile, jede Zeile ist eine Beobachtung
3.  Jeder Wert ist eine Zelle, jede Zelle ist ein Einzelwert

```{r}
#| echo: false
#| out-width: "90%"
#| label: fig-tidy
#| fig-align: center
#| fig-cap: "[Image source:](https://r4ds.hadley.nz/data-tidy.html) @wickham_r_2023 (all rights reserved)"
magick::image_read(here::here("media/Wickham_tidydata.png"))
```

## Warum 'tidy' Daten?

> "**Gl√ºckliche Familien** sind alle gleich; jede **ungl√ºckliche Familie** ist auf ihre eigene Art ungl√ºcklich." 
>
--- Leo Tolstoy

> "**'Tidy' Datens√§tze** sind alle gleich, aber jeder **'untidy' Datensatz** ist auf seine eigene Weise unordentlich."
>
--- Hadley Wickham

::: {.content-visible when-format="revealjs"}
##
:::

Die Arbeit mit aufger√§umten Daten hat zwei wesentliche Vorteile:

1. Die Arbeit mit einer konsistenten Datenstruktur erm√∂glicht es uns, Konventionen zu √ºbernehmen.
    + Aufger√§umte Daten sind die allgemein vereinbarte Datenstruktur
    + Konventionen/Werkzeuge basieren auf der Annahme dieser Struktur
2. Die vektorisierte Natur von R kann gl√§nzen
    + die meisten eingebauten R-Funktionen arbeiten mit *Vektorwerten* (und Spalten sind im Wesentlichen Vektoren)
    + Alle Pakete im `tidyverse` sind darauf ausgelegt, mit aufger√§umten Daten zu arbeiten (z.B. `ggplot2` und `dplyr`)

::: {.content-visible when-format="revealjs"}
##
:::

# Daten bereinigen (tidying)

- Umwandlung breiter Daten in lange Daten und langer Daten in breite Daten (neben anderen Schritten)
  + Ergebnis: aufger√§umte Daten (normalerweise)

## 'Tidying' Daten mit dem `tidyverse`

- Das Paket `tidyr` (aus `tidyverse`) hat zwei n√ºtzliche Funktionen zum Transponieren unserer Daten: 

  - `pivot_longer()`: macht breite Daten l√§nger
  - `pivot_wider()`: lange Daten breiter machen

::: {.content-hidden when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="100%"}
#| fig-cap-location: bottom
#| label: fig-pivot-html
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials) ([Friends](https://www.youtube.com/watch?v=8w3wmQAMoxQ))
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

::: {.content-visible when-format="pdf"}
```{r echo = F, fig.align = "center", out.width="50%"}
#| fig-cap-location: bottom
#| label: fig-pivot-pdf
#| fig-cap: die ber√ºhmteste Verwendung des Wortes Pivot (zumindest f√ºr Millenials)
magick::image_read(here::here("media/pivot_friends.jpeg"))
```
:::

## Breite versus lange Daten

- Wir m√ºssen oft zwischen breiten und langen Datenformaten konvertieren, um verschiedene Arten von Zusammenfassungen oder Visualisierungen zu erstellen

- breite Daten: alle Beobachtungen zu einer Sache befinden sich in einer einzigen Zeile
  + ist *normalerweise* nicht aufger√§umt
- lange Daten: jede Beobachtung befindet sich in einer separaten Zeile
  + ist *normalerweise* aufger√§umt

- Beginnen wir mit dem typischsten Fall: Umwandlung breiter Daten in lange Daten
  
# `pivot_longer()`

- im Datensatz `languageR_english.csv` (`df_eng`)
  - haben wir `r nrow(df_eng)` Beobachtungen (Zeilen)
  - Wir haben `r length(df_eng)` Variablen (Spalten)
  - die Spalte `age_subject` gibt an, ob eine Beobachtung von einem Teilnehmer der Altersgruppe `old` oder `young` stammt
  - die Spalten `word` und `word_category` beschreiben Eigenschaften des Stimulus f√ºr eine bestimmte Beobachtung (d. h. das Wort)
  - die Spalte `rt_lexdec` enth√§lt die Reaktionszeit f√ºr eine lexikalische Entscheidungsaufgabe
  - die Spalte `rt_naming` enth√§lt die Antwortzeit f√ºr eine Wortbenennungsaufgabe

::: {.content-visible when-format="revealjs"}
### `head(df_eng)`
:::

```{r}
#| label: tbl-df_eng
#| tbl-cap: df_eng
#| echo: false
df_eng %>% 
  head() %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling()
```

- Sind diese Daten in @tbl-df_eng aufger√§umt?
- Sind diese Daten zu breit oder zu lang?
- Wie k√∂nnen wir diese Daten l√§nger machen?

## Our goal

- wir wollen @fig-long produzieren

```{r}
#| echo: false
#| label: fig-long
#| fig-cap: Our plot to be reproduced
df_eng %>% 
  pivot_longer(
    cols = starts_with("rt_"), 
    names_to = "response", 
    values_to = "time"
  ) %>% 
  mutate(response = fct_recode(response,
                               "Lexical Decision Task" = "rt_lexdec", 
                               "Naming Task" = "rt_naming")) |> 
  ggplot() +
  aes(x = age_subject, 
      y = time, 
      colour = age_subject, 
      shape = age_subject) +
  facet_wrap(~response) +
  labs(title = "Response time by task and age group",
       x = "Age group", 
       y = "Response time (ms)") +
  geom_point(alpha = 0.4, position = position_jitter(0.2)) +
  theme_bw() +
  theme(legend.position = "none",
        text = element_text(size=16))
```
::: {.content-visible when-format="revealjs"}

###

:::

- die beiden kontinuierlichen Variablen `rt_lexdec` und `rt_naming` erscheinen in Facetten
  + `facet_wrap()` nimmt eine *kategorische* Variable als Argument und erzeugt eine Facette f√ºr jede Kategorie
- wir brauchen also eine kategorische Variable, die die Ebenen `lexdec` und `naming` enth√§lt
  + und eine *kontinuierliche* Variable, die die entsprechende Antwortzeit enth√§lt


## `pivot_longer()`

- Die Funktion `pivot_longer()` (von `tidyr`) konvertiert eine breite Datentabelle in ein l√§ngeres Format
  + wandelt die Namen der angegebenen Spalten in die Werte einer neuen kategorischen Spalte um
  + und kombiniert die Werte dieser Spalten in einer neuen Spalte

::: {.content-visible when-format="revealjs"}

```{r}
#| echo: true
df_eng_long <- 
  df_eng %>% 
  pivot_longer(
    cols = starts_with("rt_"), 
    names_to = "response", 
    values_to = "time"
  )
```

### 
:::

```{r}
#| echo: true
df_eng_long <- #<1>
  df_eng %>% #<2>
  pivot_longer( #<3>
    cols = starts_with("rt_"),  #<4>
    names_to = "response",  #<5>
    values_to = "time" #<6>
  )
```

1. Erstellen Sie ein neues Objekt namens `df_eng_long`, das...
2. `df_eng`, und dann
3. mache es l√§nger
4. indem du Spalten (`col =`) nimmst, die mit `rt_` beginnen
5. und eine Variable namens `response` erstellen, die die Namen aus `cols` enth√§lt (`names_to =`)
6. und eine Variable namens `time` erstellen, die die Werte aus `cols` enth√§lt (`values_to =`)

::: {.content-visible when-format="revealjs"}

##

:::

```{r}
df_eng_long |> head()
```



::: {.content-visible when-format="revealjs"}

##

:::

- Vergleichen wir die Beobachtungen f√ºr die W√∂rter `ace` und `act` in
  + `df_eng` (@tbl-eng)
  + `df_eng_longer ` (@tbl-longer)

:::: columns
::: {.column width="40%"}
```{r}
#| output-location: fragment
#| echo: false
#| tbl-cap: "`df_eng`"
#| label: tbl-eng
df_eng %>% 
  select(age_subject, word, rt_lexdec, rt_naming) |> 
  head(n = 4) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::

::: {.column width="10%"}

:::

::: {.column width="40%"}
```{r}
#| echo: false
#| output-location: column-fragment
#| label: tbl-longer
#| tbl-cap: "`df_eng |> pivot_longer(...)`"
df_eng_long %>% 
  select(age_subject, word, response, time) |> 
  head(n = 8) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::
::::

::: {.content-visible when-format="revealjs"}
## {.unlisted .unnumbered}
:::

- die beiden Tabellen enthalten genau die gleichen Informationen
  + 8 Werte f√ºr die Antwortzeit:
    + 4 f√ºr `rt_lexdec`
    + 4 f√ºr `rt_naming`

- Dies ist eine wichtige Erkenntnis: Wir haben keine Daten oder Beobachtungswerte ge√§ndert, sondern lediglich die Organisation der Datenpunkte neu strukturiert.

### Plotten unserer 'tidy' Daten

- Versuchen wir nun, unser Diagramm zu erstellen:
  + `age_subject` auf der x-Achse
  + `time` auf der y-Achse
  + Kategorien `response` in Facetten
  

```{r}
#| echo: false
#| label: fig-eng
#| fig-cap: Response times per age group for the lexical decision task vs. naming task
df_eng_long %>% 
  ggplot() +
  aes(x = age_subject, 
      y = time, 
      colour = age_subject, 
      shape = age_subject) +
  facet_wrap(~response) +
  labs(title = "Response time by task and age group",
       x = "Age group", 
       y = "Response time (ms)") +
  geom_point(alpha = 0.4, position = position_jitter(0.2)) +
  theme_bw() +
  theme(legend.position = "none")
```

::: {.content-visible when-format="revealjs"}
## {.unlisted .unnumbered}
:::
::: callout-tip
### [Aufgabe @exm-tidy]: Tidy data

::: {#exm-tidy .custom}
::: nonincremental
@fig-eng neu erstellen.
:::
:::
:::

# `pivot_wider()`

- Es kommt h√§ufiger vor, dass man seine Daten verl√§ngern will (man nimmt Spalten und macht aus deren Werten neue Zeilen)
  + aber manchmal m√∂chte man seine Daten auch verbreitern (man nimmt Zeilen und verwandelt ihre Werte in neue Spalten)
- Die `tidyr`-Funktion `pivot_wider()` macht Datens√§tze *breiter*, indem sie Spalten vergr√∂√üert und Zeilen reduziert.
  + Dies ist hilfreich, wenn eine Beobachtung √ºber mehrere Zeilen verteilt ist.
- Lassen Sie uns versuchen, `df_eng` breiter zu machen
  + Wir k√∂nnten zum Beispiel eine einzige Zeile pro *Wort* haben
    + mit einer einzigen Variablen f√ºr die Antwort des `young` Probanden und die Antwort des `old` Probanden

## `pivot_wider()`

- pivot wider nimmt √§hnliche Argumente wie `pivot_longer()`, mit einigen leichten Unterschieden:

  + `id_cols` (optional): identifizierende Spalten (welche Spalten identifizieren jede Beobachtung eindeutig?)
  + `names_from`: wie soll die neue Spalte hei√üen, die die vorherigen Spaltennamen enth√§lt (muss eine kategorische Variable sein)? 
  + `names_prefix` (optional): Pr√§fix f√ºr die neuen Spaltennamen (optional)
  + `values_von`: neue Spaltenwerte

##

- lassen Sie uns zwei neue Variablen erstellen, die ihre Namen von `age_subject` und ihre Werte von `rt_lexdec` √ºbernehmen

```{r}
df_eng_wide <-
  df_eng %>%  
  select(-rt_naming) |> 
  pivot_wider(
    names_from = age_subject, #<1>
    values_from = rt_lexdec, #<2>
    names_prefix = "lexdec_" #<3>
  )
```

1. neue Spaltennamen unter Verwendung der Werte in `age_subject` erstellen
2. Erstelle neue Beobachtungswerte aus `rt_lexdec`
3. Hinzuf√ºgen von `lexdec_` am Anfang der neuen Spaltennamen

##

- Vergleichen wir die Beobachtungen f√ºr die W√∂rter `ace` und `act` in
  + `df_eng` (@tbl-eng)
  + `df_eng_longer ` (@tbl-longer)


:::: columns 
::: {.column width="45%"}

```{r}
#| echo: false
#| label: tbl-df_eng-2 
#| tbl-cap: "`df_eng`"
df_eng %>% 
  select(-rt_naming) |>
  filter(word %in% c("ace", "act")) |> 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::

::: {.column width="10%"}
:::

::: {.column width="45%"}
```{r}
#| echo: false
#| eval: true
#| label: tbl-eng_wider
#| tbl-cap: "`df_eng_wide`"
df_eng %>%  
  select(-rt_naming) |>
  pivot_wider(
    names_from = age_subject,
    values_from = rt_lexdec,
    names_prefix = "lexdec_"
  ) %>% 
  filter(word %in% c("ace", "act")) |> 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```
:::
::::

- Auch hier haben wir keine Daten oder Beobachtungswerte ge√§ndert, sondern lediglich die Anordnung der Datenpunkte neu strukturiert.


::: {.content-visible when-format="revealjs"}
##
:::



## Eindeutige Werte

- Wir haben `rt_naming` entfernt, weil es auch einen eindeutigen Wert pro Wort pro Altersgruppe hat
- wir √§ndern nur die Breite und f√ºhren `NA`-Werte f√ºr `lexdec_young` f√ºr alte Themen und `NA`-Werte f√ºr `lexdec_old` f√ºr junge Themen ein
- H√§tten wir sie nicht entfernt, s√§hen unsere ersten 6 Zeilen wie @tbl-eng_wider_na aus
  + Vergleichen Sie dies mit der Ausgabe in @tbl-eng_wider, sehen Sie den Unterschied?

```{r}
#| echo: false
#| eval: true
#| label: tbl-eng_wider_na
#| tbl-cap: Wider data with missing values
df_eng %>%  
  # select(-rt_naming) |>
  pivot_wider(
    names_from = age_subject,
    values_from = rt_lexdec,
    names_prefix = "lexdec_"
  ) %>% 
  filter(word %in% c("ace", "act")) |> 
  knitr::kable() %>% 
  kableExtra::kable_styling(font_size = 20)
```


# Lernziele üèÅ {.unnumbered .unlisted}

Heute haben wir gelernt...

- √ºber breite und lange Daten ‚úÖ
- wie man breite Daten l√§nger macht ‚úÖ
- wie man lange Daten breiter macht ‚úÖ


# Hausaufgaben

F√ºr diese Aufgaben werden wir mit dem Datensatz `df_eng` arbeiten.

::: {.content-visible when-format="revealjs"}
## 
:::

```{r}
#| echo: false
#| eval: true
df_wider <-
  df_eng |> 
  select(-rt_lexdec) |> 
  pivot_wider(
    names_from = age_subject,
    values_from = rt_naming,
    names_prefix = "naming_"
  )
```


1. Verwenden Sie `pivot_wider`, um mit `rt_naming` neue Variablen zu erstellen: `naming_old` und `naming_young`, die die Reaktionszeiten beim Benennen f√ºr alte bzw. junge Teilnehmer enthalten. Hinweis: Sie m√ºssen `rt_lexdec` entfernen. Der resultierende Datenrahmen sollte `r nrow(df_wider)` Beobachtungen und `r length(df_wider)` Variablen enthalten.

::: {.content-visible when-format="revealjs"}
## 
:::

2. Erstellen Sie @fig-old_young neu. Hinweis: Sie ben√∂tigen `pivot_wider()`. 

```{r}
#| echo: false
#| eval: true
#| label: fig-old_young
#| fig-cap: Scatterplot of lexical decision task response times per word for old versus young participants
df_eng_wide |> 
  ggplot() +
  aes(x = lexdec_young, y = lexdec_old, colour = word_category) +
  geom_point()
```


::: {.content-visible when-format="revealjs"}
## 
:::


3. Warum brauchen wir den Datensatz `df_eng_wide`, um @fig-old_young zu erstellen? Mit anderen Worten, warum ist `df_eng_wide` die geeignete Struktur f√ºr ein solches Streudiagramm, aber nicht `df_eng_long`?


::: {.content-visible when-format="revealjs"}
## 
:::

4. Verwenden Sie `df_eng_long` und die Funktion `summarise()`, die wir im letzten Abschnitt gesehen haben, um die folgende Zusammenfassung zu reproduzieren:

```{r}
#| echo: false
df_eng_long |> 
  drop_na() |> 
  summarise(
    mean = mean(time),
    sd = sd(time),
    .by = response
  )
```

Hinweis: M√ºssen Sie `NA` entfernen (wir haben letzen Woche gesehen, wie man das macht)?

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
RStudio.Version()$release_name
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.9.0.463 (Desert Sunflower).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::