---
title: "Datentransformation"
subtitle: "Arbeiten mit Zeilen und Spalten"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 4 - Datenumwandlung" 
lang: de
date: "11/08/2023"
date-format: "ddd [d]en DD.MM.YYYY"
date-modified: last-modified
format: 
  html:
    output-file: wrangling1_blatt.html
    include-after-body: custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
  revealjs: 
    output-file: wrangling1_folien.html
    include-after-body: custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: true
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
  pdf:
    output-file: wrangling1.pdf
    toc: true
    number-sections: true
    colorlinks: true
    code-overflow: wrap
bibliography: ../../references.bib
csl: ../../apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, # evaluate chunks
                      echo = T, # 'print code chunk?'
                      message = F, # 'print messages (e.g., warnings)?'
                      error = F, # stop when error encountered
                      warning = F) # don't print warnings
```

```{r, eval = T, cache = F}
#| echo: false
# Create references.json file based on the citations in this script
# make sure you have 'bibliography: references.json' in the YAML
# rbbt::bbt_update_bib("_wrangling1_DE.qmd")
```

# Wiederholung {.unnumbered}

Letze Woche haben wir...

-   gelernt, was dynamische Berichte sind 
-   unser eigenes Quarto-Dokument erstellt
-   gelernt, wie man ein Quarto-Dokument bearbeitet
-   gelernt, wie man Code in ein Quarto-Dokument einf√ºgt
-   ein Quarto-Dokument in verschiedenen Formaten wiedergebt

# Heutige Ziele {.unnumbered}

Heute werden wir...

- lernen, wie man Daten mit dem Paket `dplyr` aus dem `tidyverse` verarbeitet
- lernen, wie man die `pipe` (`|>`) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen
- Funktionen kennenlernen, die auf Zeilen operieren
- Funktionen kennenlernen, die mit Spalten arbeiten
- lernen, wie man `dplyr`-Funktionen mit Plots von `ggplot2` kombiniert

## Lust auf mehr? {.unnumbered .unlisted}

- [Kapital 4 (Data transformation)](https://r4ds.hadley.nz/data-transform.html) in @wickham_r_nodate
- [Kapital 9 (Data wrangling)](https://psyteachr.github.io/ads-v2/09-wrangle.html) in @nordmann_applied_2022

# Voraussetzungen

1. Frisches Quarto-Dokument
    - Erstellen Sie ein neues Quarto-Dokument f√ºr den heutigen Unterricht
      - Datei > Neues Dokument > Quarto Dokument, mit dem Namen `04-wrangling`
    - YAML einrichten: Titel, Ihr Name, ein `toc` hinzuf√ºgen

```{r}
#| eval: false
#| code-line-numbers: false
title: "Data wrangling"
subtitle: "Transforming data"
author: "Your name here"
lang: de
date: "11/08/2023"
format: 
  html:
    toc: true
```

::: {.content-visible when-format="revealjs"}
## Voraussetzungen {.unlisted .unnumbered}
:::

2. Pakete
    - Die heutigen Pakete sind:
      - `tidyverse`: zum Verarbeiten (`dplyr`) und Plotten (`ggplot2`)
      - `languageR`: f√ºr linguistische Datens√§tze

```{r}
library(tidyverse)
library(languageR)
```

::: {.content-visible when-format="revealjs"}
## Voraussetzungen {.unlisted .unnumbered}
:::

3. Daten
    - wir arbeiten wieder mit dem `lexdec`-Datensatz aus dem `languageR`-Paket [@languageR-package]
    - wir speichern ihn als Objekt mit dem Namen `df_lexdec`
    - wir wandeln auch die Variable `RT` um, so dass sie in Millisekunden angegeben wird (vorher war sie in log Millisekunden angegeben, aber machen Sie sich keine Gedanken dar√ºber, was das bedeutet)
    - und wir w√§hlen 10 Variablen aus, die f√ºr uns heute relevant sind
    
```{r}
df_lexdec <- lexdec |> 
  mutate(RT = exp(RT)) |> 
  select(Subject, RT, Trial, Sex, NativeLanguage, Correct, Word, Frequency, Class, Length)
```



::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Rendernpause!
::: nonincremental
Nehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wurde es gerendert?

- Hat es einen Titel?
- Enth√§lt es Ihren Namen?
- Hat es eine √úberschrift f√ºr "Pakete"?
- F√ºgen Sie eine √úberschrift f√ºr 'Data Wrangling' hinzu

:::

:::

:::

# Data Wrangling

- Im Englischen bezieht sich "wrangling" auf einen langen, schwierigen Prozess
  + z. B. treiben Cowboys ihre Rinder oder Herden zusammen (sammeln, sammeln ihre Tiere)
- Es gibt zwei Hauptbestandteile des Wrangling
  + Transformieren: Sortieren oder Erstellen neuer Variablen (was wir heute tun werden)
  + Aufr√§umen: Umformung oder Strukturierung Ihrer Daten (dies werden wir in einigen Wochen tun)
- Sowohl das Aufr√§umen als auch das Transformieren von Daten erfordern das Paket `dplyr` aus dem `tidyverse`.
  + `dplyr` Funktionen werden oft als Verben bezeichnet, weil sie etwas *tun*

::: {.content-visible when-format="revealjs"}
## `dplyr` {.unlisted .unnumbered}
:::

::: callout-tip

# Der Name `dplyr`
  + Der Name `dplyr` kommt von einem fr√ºheren Paket, `plyr`, das dazu verwendet wird, Daten zu zerlegen, Funktionen darauf anzuwenden und zu kombinieren
    + Im Englischen klingt `plyr` wie das Wort f√ºr Zangen ("pliers"), die benutzt werden, um Dinge auseinander zu nehmen, wie das, was `plyr` mit Daten macht
    + das "d" in "dplyr" wurde hinzugef√ºgt, weil das Paket speziell f√ºr die Arbeit mit Datenrahmen gedacht ist
    
:::


## `lexdec`

- der `lexdec`-Datensatz enth√§lt Daten f√ºr eine lexikalische Entscheidungsaufgabe im Englischen
  + Schauen wir uns den Datensatz mit der Funktion `head()` an, die nur die ersten 6 Zeilen ausgibt
    + hier geben wir die ersten 10 Zeilen aus

```{r}
#| eval: false
#| echo: false

head(df_lexdec, n = 10)
```


- In meinen Materialien verwende ich oft die Funktion "head()", um zu vermeiden, dass der gesamte Datensatz in der Ausgabe gedruckt wird, aber Sie w√ºrden im Allgemeinen nicht "head()" verwenden wollen, wenn Sie Ihre Daten betrachten, sondern Ihren gesamten Datensatz betrachten wollen

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-df_lexent]: `df_lexdec`
::: {#exm-df_lexent .custom}
::: nonincremental
1. Betrachten Sie den Datensatz
    + wie viele Beobachtungen gibt es?
    + Wie viele Variablen gibt es?
2. Geben Sie den Datensatz in die Funktion `glimpse()` ein.
    + Was zeigt Ihnen das?
    + Wie sieht es im Vergleich zu dem aus, was Sie sehen, wenn Sie `summary()` verwenden?

:::
:::
:::


## `dplyr`-Grundlagen

- heute lernen wir einige der wichtigsten `dplyr`-Verben (Funktionen) kennen, mit denen wir die meisten unserer Datenmanipulationsprobleme l√∂sen k√∂nnen
  + Ich verwende diese Verben mehrfach in wahrscheinlich jedem Analyseskript
- Die `dplyr`-Verben haben einige Dinge gemeinsam:
    1. das erste Argument ist immer ein Datenrahmen
    2. die folgenden Argumente beschreiben in der Regel die zu bearbeitenden Spalten, wobei der Variablenname (ohne Anf√ºhrungszeichen) verwendet wird
    3. die Ausgabe ist immer ein neuer Datenrahmen

::: {.content-visible when-format="revealjs"}
## `dplyr` Grundlagen
:::

- Die Verben sind alle f√ºr eine Sache gut geeignet, so dass wir oft mehrere Verben auf einmal verwenden wollen.
  + Wir verwenden dazu die Pipe (`|>` oder `|>`)
  + Wir haben diese Pipe bereits gesehen, als wir einen Datenrahmen in `ggplot()` einspeisten.
  + wir k√∂nnen die Pipe als `und dann` lesen

::: {.content-visible when-format="revealjs"}
## `dplyr` Grundlagen
:::

- In dem folgenden Code identifizieren
  + den Datenrahmen
  + `dplyr`-Verben
  + Variablennamen
- Kannst du versuchen, herauszulesen (zu erraten), was der folgende Code macht?

```{r}
#| eval: false
df_lexdec |> 
  filter(Subject == "A1") |> 
  select(Subject, Trial, RT, NativeLanguage, Word) |> 
  relocate(NativeLanguage, .after = Trial)
```

::: {.content-visible when-format="revealjs"}

```{r}
#| eval: false
df_lexdec |> 
  filter(Subject == "A1") |> 
  select(Subject, Trial, RT, NativeLanguage, Word) |> 
  relocate(NativeLanguage, .after = Trial)
```

:::

::: {.content-visible when-format="revealjs"}
## {.unnumbered .uncounted .unlisted}
:::

::: callout-tip
## Korrekte Syntax

.Beachten Sie, dass `A1` mit Anf√ºhrungszeichen geschrieben wird, aber keiner der anderen Codes. Wenn wir ein Objekt (z.B. `df_lexdec`) oder seine Variablen (z.B. `Subject`) aufrufen, setzen wir sie nicht in Anf√ºhrungszeichen. Wenn wir einen bestimmten *Wert* einer Variablen aufrufen, der nicht numerisch ist, m√ºssen wir diesen Wert in Anf√ºhrungszeichen setzen, weil die Subject ID `A1` ein Wert der Variablen `Subject` ist, m√ºssen wir sie in Anf√ºhrungszeichen setzen.

Versuchen Sie, die Anf√ºhrungszeichen zu entfernen. Welche Fehlermeldung erhalten Sie?

Versuchen Sie, einen Variablennamen in Anf√ºhrungszeichen zu setzen, welche Fehlermeldung erhalten Sie?

Dies ist eine wichtige √úbung, denn Sie werden oft feststellen, dass Ihr Code nicht l√§uft, aber die L√∂sung ist oft etwas so Einfaches wie fehlende oder zus√§tzliche Anf√ºhrungszeichen oder Interpunktion.

:::

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Rendernpause!
::: nonincremental
Nehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?

K√∂nnen Sie das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

# Zeilen

- In aufger√§umten Daten stellen die Zeilen Beobachtungen dar.

- die wichtigsten Verben f√ºr Zeilen sind:
  + `filter()`: √§ndert, welche Zeilen vorhanden sind
  + `arrange()`: √§ndert die Reihenfolge der Zeilen
- Wir besprechen auch
  + `distinct()`: findet Zeilen mit unterschiedlichen Werten basierend auf einer Variablen (Spalte)

## `filter()`

- √§ndert, welche Zeilen vorhanden sind, ohne ihre Reihenfolge zu √§ndern
- nimmt den Datenrahmen als erstes Argument
  + Die folgenden Argumente sind Bedingungen, die `TRUE` sein m√ºssen, damit die Zeile erhalten bleibt
  
::: {.content-visible when-format="revealjs"}
## `filter()` {.unlisted .unnumbered}
:::
  
- findet alle Reaktionszeiten, die l√§nger als 450 Millisekunden waren:

```{r}
#| output-location: fragment
df_lexdec |> 
  filter(RT > 450) |> 
  head()
```

- Beachten Sie, dass wir den Wert der Reaktionszeit nicht in Anf√ºhrungszeichen setzen, da er *numerisch* ist

::: {.content-visible when-format="revealjs"}
## `filter()` {.unlisted .unnumbered}
:::

- wenn Sie die gefilterten Daten speichern wollen, ist es in der Regel ratsam, sie unter einem *neuen* Objektnamen zu speichern
  + wenn Sie die vorgefilterte Version nicht √ºberschreiben wollen, ist ein neuer Name erforderlich

```{r}
df_lexdec_450 <- 
  df_lexdec |> 
  filter(RT > 450)
```

::: {.content-visible when-format="revealjs"}
## Logische Operatoren {.unlisted .unnumbered}
:::

::: callout-note

### Logische Operatoren
::: nicht-inkrementelle
- Symbole, die zur Beschreibung einer logischen Bedingung verwendet werden
  - `==` *ist identisch* (`1 == 1`)
  - `!=` *ist nicht identisch* (`1 != 2`)
  - `>` *ist gr√∂√üer als* (`2 > 1`)
  - `<` *ist kleiner als* (`1 < 2`)
- um Bedingungen zu kombinieren
  - `&` oder `,` *und auch* (f√ºr mehrere Bedingungen)
  - `|` *oder* (f√ºr mehrere Bedingungen)

- es gibt eine nette Abk√ºrzung f√ºr die Kombination von `==` und `|`: `%in%`
  + beh√§lt Zeilen, in denen die Variable gleich einem der Werte auf der rechten Seite ist

::: panel-tabset
### `==` und `|`
```{r}
df_lexdec |> 
  filter(Trial == 30 | Trial == 23) |> 
  head()
```

### `%in%`
```{r}
df_lexdec |> 
  filter(Trial %in% c(30, 23)) |> 
  head()
```
:::
:::
:::

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-filter]: `filter()`
::: {#exm-filter .custom}
::: nonincremental
1. Filtern Sie die Daten, um Zeilen aus Versuch 25 und Nicht-Muttersprachler (`andere`) einzuschlie√üen.
2. Wie viele Zeilen gibt es?
:::
:::
:::

```{r}
#| eval: false
#| echo: false

# 1, 2
df_lexdec |> 
  filter(Trial == 25,
         NativeLanguage == "Other") |> 
  count()
```


## `arrange()`

- √§ndert die Reihenfolge der Zeilen auf der Grundlage eines Wertes in einer oder mehreren Spalten

```{r}
#| output-location: fragment
df_lexdec |> 
  arrange(RT) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## `arrange()` {.unlisted .unnumbered}
:::

- wenn Sie mehr als einen Spaltennamen verwenden, wird jede zus√§tzliche Spalte verwendet, um die Verbindung zwischen den Werten der vorangegangenen Spalten zu l√∂sen

```{r}
#| output-location: fragment
df_lexdec |> 
  arrange(Length,Sex) |> 
  head(10)
```

::: {.content-visible when-format="revealjs"}
## `arrange()` {.unlisted .unnumbered}
:::

- wir k√∂nnen `desc()` innerhalb von `arrange()` hinzuf√ºgen, um eine absteigende Reihenfolge (gro√ü-klein) anstelle der standardm√§√üigen aufsteigenden Reihenfolge zu verwenden

```{r}
#| output-location: fragment
df_lexdec |> 
  arrange(desc(Length)) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-arrange]: `arrange()`
::: {#exm-arrange .custom}
::: nonincremental
1. Filtere die Daten so, dass sie nur Beobachtungen der "Probanden" M1 und W2 enthalten, *und dann*
2. Ordnen Sie die Daten nach absteigender Reaktionszeit
  
```{r}
#| eval: false
#| echo: false

df_lexdec |> 
  filter(Subject %in% c("M1", "W2")) |> 
  arrange(desc(RT)) |> 
  head()
```
:::
:::
:::

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}

::: {.callout-important appearance="simple"}
### Rendernpause!
::: nonincremental
Nehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?

K√∂nnen Sie das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::

:::

# Spalten

- In Tidy Data stellen die Spalten Variablen dar.

- die wichtigsten Verben f√ºr Spalten sind:
  + `rename()`: √§ndert die Namen der Spalten
  + `mutate()`: erzeugt neue Spalten, die von den vorhandenen Spalten abgeleitet werden
  + `select()`: √§ndert, welche Spalten vorhanden sind
  + `relocate()`: √§ndert die Position der Spalten

## `rename()`

- Mit `rename()` k√∂nnen wir den Namen von Spalten √§ndern
  + die Reihenfolge der Argumente ist `neuer_name` = `alter_name`
  
- Versuchen wir, einige der Variablennamen auf Deutsch zu √§ndern
  + Ich neige dazu, Variablennamen in Kleinbuchstaben zu schreiben, als Kodierungskonvention
  
```{r}
# single variable
df_lexent <- 
  df_lexdec |>
  rename(teilnehmer = Subject)

# or multiple variables at once
df_lexent <- 
  df_lexdec |> 
 rename(teilnehmer = Subject,
        rz_ms = RT,
        geschlect = Sex,
        laenge = Length)
```

## `mutate()`

- Mit `mutate()` werden neue Spalten aus vorhandenen Spalten erzeugt.
  + So k√∂nnen wir z.B. einfache Algebra mit den Werten in jeder Spalte durchf√ºhren

```{r}
#| Ausgabeort: Fragment
df_lexent |> 
  mutate(
    rz_laenge = rz_ms / laenge,
  ) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## `mutate()` {.unlisted .unnumbered}
:::

- Mit `mutate()` werden diese neuen Spalten auf der rechten Seite des Datensatzes hinzugef√ºgt.
  + Das macht es schwierig zu sehen, was passiert.
- um zu kontrollieren, wo die neue Spalte hinzugef√ºgt wird, k√∂nnen wir `.before` oder `.after` verwenden

```{r}
#| output-location: fragment
df_lexent |> 
  mutate(
    rz_laenge = rz_ms / laenge,
    .after = rz_ms
  ) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
##  {.unlisted .unnumbered}
:::

::: {.callout-important appearance="simple"}
### Rendernpause!
::: nonincremental
Nehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?

K√∂nnen Sie das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::


::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-mutate]: `mutate()`
::: {#exm-mutate .custom}
::: nonincremental

1. Create a new variable called `rz_s` in `df_lexent`:
    - equals `rz_ms` divided by 1000 (i.e., converts milliseconds to seconds)
    - appears after `rz_ms`
2. Render your document

```{r}
#| echo: false
#| eval: true
df_lexent <-
  df_lexent |> 
  mutate(
    rz_s = rz_ms / 1000,
    .after = rz_ms
  )
```

:::

:::

:::

## `select()`

- `select()` fasst die Daten so zusammen, dass sie nur die gew√ºnschten Spalten enthalten

- Spalten nach Namen ausw√§hlen

```{r}
#| output-location: fragment
df_lexent |> 
  select(teilnehmer, rz_ms, Word) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## `select()` {.unlisted .unnumbered}
:::

- select alle Spalten zwischen `rz_ms` und `geschlecht`

```{r}
#| output-location: fragment
df_lexent |> 
  select(rz_ms:geschlect) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## `select()` {.unlisted .unnumbered}
:::

- alle Spalten au√üer `rz_s` ausw√§hlen (`!` wird als "nicht" gelesen)

```{r}
#| output-location: fragment
df_lexent |> 
  select(!rz_s) |> 
  head()
```

## `select()`-Hilfsfunktionen

- einige Hilfsfunktionen, die das Leben bei der Arbeit mit `select()` erleichtern:
  + `starts_with("abc")`: w√§hlt Spalten aus, die mit einer bestimmten Zeichenkette beginnen
  + `ends_with("xyz")`: w√§hlt Spalten aus, die mit einer bestimmten Zeichenkette enden
  + `contains("ijk")`: w√§hlt Spalten aus, die eine bestimmte Zeichenkette enthalten
  + `where(is.character)`: w√§hlt Spalten aus, die einem logischen Kriterium entsprechen
    + z.B. gibt die Funktion `is.character()` den Wert `TRUE` zur√ºck, wenn eine Variable Zeichenketten enth√§lt, nicht numerische Werte oder Kategorien

:::: columns

::: {.column width="50%"}
```{r}
#| output-location: fragment
df_lexent |> 
  select(starts_with("w")) |> 
  head()
```
:::

::: {.column width="50%"}
```{r}
#| output-location: fragment
df_lexent |> 
  select(ends_with("er")) |> 
  head()
```
:::
::::

::: {.content-visible when-format="revealjs"}
## Aufgabe {.unlisted .unnumbered}
:::

::: callout-tip

### [Aufgabe @exm-select]: `select()`
::: {#exm-select .custom}
::: nonincremental

1. Drucke die Spalten in `df_lexent`, die mit "t" beginnen
2. Drucke die Spalten in `df_lexent`, die "ge" enthalten
3. Drucke die Spalten in `df_lexent`, die
    + mit mit "r" beginnen, und
    + mit "s" enden

:::
:::
:::
  
```{r}
#| echo: false
#| eval: false

# 1
df_lexent |>
  select(starts_with("t")) |> 
  head()
# 2
df_lexent |>
  select(contains("ge")) |> 
  head()
# 3
df_lexent |>
  select(starts_with("r"),
         ends_with("s")) |> 
  head()
```


## `relocate()`

- `relocate()` verschiebt Variablen
  + standardm√§√üig werden sie nach vorne verschoben

```{r}
#| output-location: fragment
df_lexent |> relocate(Trial) |> 
  head()
```

::: {.content-visible when-format="revealjs"}
## `relocate()` {.unlisted .unnumbered}
:::

- aber wir k√∂nnen auch `.before` oder `.after` verwenden, um eine Variable zu platzieren

```{r}
#| output-location: fragment
df_lexent |> 
  relocate(Trial, .after = teilnehmer) |> 
  head()
```

# `dplyr` und `ggplot2`

- wir k√∂nnen einen Datensatz mit den `dplyr`-Verben √§ndern und diese √Ñnderungen dann in `ggplot2` einspeisen

- Was wird der folgende Code ergeben?

```{r}
#| eval: false
df_lexent |> 
  # filter the data
  filter(rz_ms > 120,
         rz_ms > 500) |> 
  # plot the filtered data
  ggplot(aes(x = fct_infreq(Correct))) +
  geom_bar() +
  theme_minimal()
```

## Pipe versus plus (`|>` vs. `+`)

- wichtig: wir k√∂nnen Pipes (` |> `) verwenden, um zus√§tzliche Verben/Funktionen mit dem Ergebnis einer vorherigen Codezeile auszuf√ºhren
  + Die Funktion `ggplot()` verwendet jedoch `+`, um neue *Ebenen* zur Darstellung hinzuzuf√ºgen
  
::: {.content-visible when-format="revealjs"}
## {.unlisted .unnumbered}
:::

::: {.callout-important appearance="simple"}
### Rendernpause!
::: nonincremental
Nehmen Sie sich einen Moment Zeit, um Ihr Dokument zu rendern. Wird es gerendert?

K√∂nnen Sie das Dokument besser strukturieren? Z. B. durch Hinzuf√ºgen von mehr √úberschriften, Text?

:::

:::


## Aufgaben

::: nonincremental

1. Drucken Sie in einer einzigen Pipeline `df_lexent`, wobei Sie nur die Spalten Reaktionszeiten (in Millisekunden), NativeLanguage und Word f√ºr Zeilen ausw√§hlen, die jede der folgenden Bedingungen erf√ºllen, sie in der Reihenfolge der Reaktionszeiten anordnen und so filtern, dass nur diese Zeilen ber√ºcksichtigt werden:
    - die Reaktionszeiten waren gr√∂√üer als 500ms *und* kleiner als 550ms
    - aus den W√∂rtern "pear", "elephant" oder "tortoise" stammen

```{r}
#| eval: false
#| echo: false

df_lexent |>
  select(rz_ms, NativeLanguage, Word) |> 
  arrange(rz_ms) |> 
  filter(rz_ms <= 550 & rz_ms > 500,
         Word %in% c("tortoise", "elephant", "pear")) 
```


2. Sortiere `df_lexent` in absteigender Reihenfolge, um die Versuche mit den l√§ngsten Reaktionszeiten zu finden.

```{r}
#| eval: false
#| echo: false

df_lexent |> 
  arrange(desc(rz_ms)) 
```

:::

::: {.content-visible when-format="revealjs"}
## {.unlisted .unnumbered}
:::

::: nonincremental
3. Speichern Sie in einer einzigen Pipeline ein neues Objekt namens `df_rz`, das `df_lexent` enth√§lt, *und dann*:
    + Selektieren Sie die Variablen `Teilnehmer`, `NativeLanguage`, `Word`, `rz_s`, `laenge`, und `Frequency`
    + Erstelle eine neue Variable `rz_s_laenge`, die `rz_s` geteilt durch `laenge` ist
      + und wird vor `Laenge` gesetzt
    + Benennen Sie diese Variablen in Englisch um, so dass sie in Deutsch (und mit Kleinbuchstaben) sind.

```{r}
#| echo: false
df_rz <- 
  df_lexent |> 
  select(teilnehmer, NativeLanguage, Word, rz_s, laenge, Frequency) |> 
  mutate(rz_s_laenge = rz_s/laenge, .before = laenge) |> 
  rename(muttersprache = NativeLanguage,
         wort = Word,
         frequenz = Frequency) # etcetera
```
:::

# Heutige Ziele üèÅ {.unnumbered .unlisted}

Heute haben wir gelernt...

- wie man Daten mit dem Paket `dplyr` aus dem `tidyverse` verarbeitet ‚úÖ
- wie man die `pipe` (` |> `) verwendet, um das Ergebnis einer Funktion in eine andere Funktion einzuspeisen ‚úÖ
- √ºber Funktionen, die auf Zeilen operieren ‚úÖ
- √ºber Funktionen, die auf Spalten operieren ‚úÖ
- wie man `dplyr`-Funktionen mit Plots von `ggplot2` kombiniert ‚úÖ

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.9.0.463 (Desert Sunflower).

```{r}
sessionInfo()
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::