---
title: "Datenvisualisierung 4"
subtitle: "Mehrteilige Plots und Anpassungen"
author: "Daniela Palleschi"
institute: Humboldt-Universit√§t zu Berlin
footer: "Woche 12 - Datenvisualisierung 4" 
lang: de
date: "`r Sys.Date()`"
format: 
  html:
    output-file: data_viz4_blatt_DE.html
    include-after-body: ../../custom.html
    number-sections: true
    number-depth: 3
    toc: true
    toc-title: "heutige Themen"
    code-overflow: wrap
    code-tools: true
    self-contained: true
    execute:
      fig-width: 6
      fig-asp: .618
      fig-align: centre
  revealjs: 
    output-file: data_viz4_folien_DE.html
    include-after-body: ../../custom.html
    theme: [dark]
    width: 1600
    height: 900
    progress: true
    # smaller: true
    scrollable: true
    slide-number: c/t
    code-link: true
    code-overflow: wrap
    code-tools: true
    # logo: logos/hu_logo.png
    # css: logo.css
    incremental: true
    number-depth: 1
    toc: false
    toc-depth: 1
    toc-title: '√úberblick'
    navigation-mode: linear
    controls-layout: bottom-right
    fig-cap-location: top
    font-size: 0.6em
    # slide-level: 4
    self-contained: true
    # chalkboard: true
    title-slide-attributes: 
      data-background-image: logos/logos.tif
      data-background-size: 15%
      data-background-position: 50% 92%
    execute:
      fig-width: 6
      fig-asp: .618
      fig-align: centre
  pdf:
    toc: true
    toc-depth: 1
    number-sections: true
    colorlinks: true
    code-overflow: wrap
    execute:
      out-width: "80%"
      fig-asp: .618
      fig-align: centre
bibliography: ../../references.bib
csl: ../../apa.csl
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
knitr::opts_chunk$set(eval = T, ## evaluate chunks
                      echo = T, ## 'print code chunk?'
                      message = F, ## 'print messages (e.g., warnings)?'
                      error = T, ## continueeven when error encountered
                      warning = F) ## don't print warnings
```

# Lesungen {.unnumbered}

F√ºr weitere Lekt√ºre und √úbungen zu diesem Thema empfehle ich die Lekt√ºre von [Abschnitt 11.5 (Kommunikation: Themen)](https://r4ds.hadley.nz/communication#sec-themes) in @wickham_r_2023 und [Kapitel 4 (Darstellung von zusammenfassenden Statistiken)](https://psyteachr.github.io/introdataviz/representing-summary-statistics.html) in @nordmann_data_2022.

# Lernziele {.unnumbered}

In diesem Abschnitt werden wir lernen

- mehrteilige Diagramme zu erstellen
- die Position von Geomen anzupassen
- unsere Diagramme f√ºr eine bessere Datenkommunikation anzupassen

# Einrichten {.unnumbered}

## Pakete {.unnumbered}

Heute laden wir unsere relevanten `tidyverse`-Pakete direkt: `dplyr` und `ggplot`. Dies sind die einzigen Pakete, die uns beim Laden unserer Daten helfen. Wir laden auch das `here`-Paket und das `janitor`-Paket, das f√ºr das Aufr√§umen unserer Daten n√ºtzlich ist (z.B. die Funktion `clean_names()`). Um unsere Diagramme anzupassen, verwenden wir auch die Pakete `ggthemes` und `patchwork`. Ersteres hilft uns bei der Erstellung von farbenblindenfreundlichen Plots, w√§hrend letzteres uns erlaubt, mehrere Plots zusammen zu drucken. Wir brauchen auch ein neues Paket: `gghalves`.

```{r}
pacman::p_load(tidyverse,
               here,
               janitor,
               ggthemes,
               patchwork,
               gghalves
               )
```

```{r}
#| echo: false
# load magick for the slides
pacman::p_load(magick)
```

## Daten {.unnumbered}

Wir arbeiten wieder mit unserer leicht ver√§nderten Version des `english`-Datensatzes aus dem Paket `languageR`.

```{r}
df_eng <- read_csv(
  here(
    "daten",
    "languageR_english.csv"
  )
) |> 
  clean_names() |> 
  rename(
    rt_lexdec = r_tlexdec,
    rt_naming = r_tnaming
  )
```

# Ausweichende Dichteplots

Wir k√∂nnen Dichteplots entlang einer katgorischen Variable erstellen, indem wir `geom_half_violin()` aus dem Paket `gghalves` verwenden. 

```{r}
#| label: fig-density
#| fig-cap: "Dodged density plots with `gghalves::geom_half_violin()`"
#| output-location: column-fragment
df_eng %>% 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_half_violin(alpha = .8)
```

## Hinzuf√ºgen eines Boxplots

Wir k√∂nnen auch ein weiteres Geom hinzuf√ºgen, um dem Diagramm weitere Informationen hinzuzuf√ºgen. F√ºgen wir einen Boxplot hinzu.

```{r}
#| label: fig-boxplot
#| fig-cap: "Boxplot on top of our dodged density plot"
#| output-location: column-fragment
df_eng %>% 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_half_violin(alpha = .8) +
  geom_boxplot()
```


## `position_nudge()`

Vielleicht wollen wir den Boxplot so verschieben, dass er nicht √ºber den Dichteplots liegt und nicht ganz so breit ist. Wir k√∂nnen dies tun, indem wir `position` auf `position_nudge()` und `width` auf einen Wert kleiner als `.75` setzen, was die Standardbreite ist.

```{r}
#| label: fig-boxplot-nudge
#| fig-cap: "Boxplot on top of our dodged density plot"
#| output-location: column-fragment
df_eng %>% 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_half_violin(alpha = .8) +
  geom_boxplot(width = .3, # make less wide
               position = position_nudge(x=0.2)
               )
```

## `position_jitter()` f√ºr Scatterplots

Dies geh√∂rt zu einer Familie von Optionen, mit denen man die Position von Geomen ver√§ndern kann. Zum Beispiel zeigen @fig-jitter A und B beide genau die gleichen Daten, aber @fig-jitter B enth√§lt `position = position_jitter(0.2)`, um √ºberlappende Punkte zu verschieben. Auf diese Weise erhalten wir eine gute Vorstellung davon, wie viele Beobachtungen es √ºber die Reaktionszeiten hinweg gab (y-Achse).

```{r}
#| code-fold: true
#| label: fig-jitter
#| fig-cap: "Plotting points along a categorical variable without (A) and with (B) position = position_jitter(0.2). Plot B also includes alpha = 0.2"
#| fig-width: 10
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_point() +
  labs(title = "geom_point()") +
df_eng |> 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_point(position = position_jitter(0.2),
             alpha = 0.2)+
  labs(title = "geom_point(position = position_jitter(0.2))") +
  
  plot_annotation(tag_levels = "A")
```

## Kombiniert alle drei

Wenn wir alle diese Diagramme zusammenf√ºgen, erhalten wir eine @fig-violin1. 

```{r}
#| code-fold: true

fig_no_colour <-
  df_eng %>% 
  ggplot() +
  aes(x = age_subject, y = rt_lexdec) +
  geom_point(position = position_jitter(0.2),
             alpha = 0.2) +
  geom_half_violin() +
  geom_boxplot(
    outlier.shape = NA,
               width = .3, 
               position = position_nudge(x=0.2)) 

```

```{r}
#| echo: false
#| label: fig-violin1
#| fig-cap: "Density, boxplot, scatterplot"
#| output-location: column-fragment
#| code-line-numbers: "3"
#| fig-width: 6
#| fig-asp: .6
fig_no_colour 
```

# Positionierung von Fehlerbalkenplots

Im zweiten Bericht haben Sie Fehlerbalkenplots erstellt, aber die Fehlerbalken haben sich √ºberschnitten. 

```{r}
#| echo: false
#| label: fig-bericht2
#| fig-cap: Overlapping errorbars
df_eng |> 
  pivot_longer(
    cols = c(rt_lexdec, rt_naming),
    names_to = "task",
    values_to = "rt"
  ) |> 
  summarise(
    mean = mean(rt, na.rm = T),
    sd = sd(rt, na.rm = T),
    .by = c(age_subject, task)
  ) |> 
  mutate(age_subject = factor(age_subject, levels = c("young", "old"))) |> ggplot() +
  aes(x = age_subject, y = mean, colour = task, shape = task) +
  geom_point() +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd))
```


## `pivot_longer() |> summarise()`

Lassen Sie uns etwas √Ñhnliches mit dem Datensatz "Englisch" nachstellen. Zuerst werden wir `pivot_longer()` verwenden, um unsere Daten zu verl√§ngern, dann erstellen wir eine Zusammenfassung der Reaktionszeiten f√ºr die lexikalische Entscheidungsaufgabe und die Benennungsaufgabe pro Altersgruppe.

```{r}
sum_eng <-
  df_eng |> 
  pivot_longer(
    cols = c(rt_lexdec, rt_naming),
    names_to = "task",
    values_to = "rt"
  ) |> 
  summarise(
    mean = mean(rt, na.rm = T),
    sd = sd(rt, na.rm = T),
    .by = c(age_subject, task)
  ) |> 
  mutate(age_subject = factor(age_subject, levels = c("young", "old"))) 
```

## √úberlappende Fehlerbalken

Wenn wir f√ºr diese Daten ein Fehlerbalken-Diagramm erstellen, erhalten wir @fig-overlap.

```{r}
#| label: fig-overlap
#| fig-cap: Overlapping errorbar plot
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean, colour = task, shape = task) +
  geom_point() +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd))
```

## `position_dodge()` 

Wir k√∂nnen `position = position_dodge(0.2)` hinzuf√ºgen, damit sich die Fehlerbalken nicht √ºberlappen. Wir werden auch ihre `width` anpassen, damit sie nicht so breit sind (jeder Wert unter 0.75).

```{r}
#| label: fig-miss-points
#| fig-cap: Overlapping errorbar plot
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean, colour = task, shape = task) +
  geom_point() +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),
                position = position_dodge(0.2),
                width = 0.2)
```

## Ausweichen vor allen relevanten Geomen

Aber jetzt haben wir die Punkte hinter uns gelassen. Wir m√ºssen auch den Punkten ausweichen, also f√ºgen wir `position_dodge()` zu `geom_point()` hinzu und stellen sicher, dass wir den gleichen Wert wie bei `geom_errorbar()` verwenden.

```{r}
#| label: fig-dodged
#| fig-cap: Overlapping errorbar plot
sum_eng |> 
  ggplot() +
  aes(x = age_subject, y = mean, colour = task, shape = task) +
  geom_point(position = position_dodge(0.2)) +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd),
                position = position_dodge(0.2),
                width = 0.2)
```

# Anpassungen

Welche Anpassungen sehen Sie in den Diagrammen in @fig-custom?

```{r}
#| code-fold: true

fig_dens_colour <-
  df_eng %>% 
  ggplot(aes(x = age_subject, y = rt_lexdec, )) +
  geom_point(
    color = "grey",
    position = position_jitter(0.2),
                 alpha = 0.2) +
  geom_half_violin(
    aes(fill = age_subject)) +
  geom_boxplot(
    outlier.shape = NA,
    aes(color = age_subject),
               width = .3, 
               position = position_nudge(x=0.2)) +
  labs(title = "Distribution of reaction times",
       x = "Age group",
       y = "LDT reaction time (ms)",
    fill = "Age group") +
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme_minimal() +
  theme(legend.position = "none") 

fig_point_colour <-
  df_eng %>% 
  ggplot(aes(x = age_subject, y = rt_lexdec, )) +
  geom_point(
    aes(color = age_subject),
    position = position_jitter(0.2),
                 alpha = 0.2) +
  geom_half_violin() +
  geom_boxplot(
    outlier.shape = NA,
    # aes(color = age_subject),
               width = .3, 
               position = position_nudge(x=0.2)) +
  labs(title = "Distribution of reaction times",
       x = "Age group",
       y = "LDT reaction time (ms)",
    fill = "Age group") +
  scale_color_colorblind() +
  scale_fill_colorblind() +
  theme_minimal() +
  theme(legend.position = "none")

fig_default <-
  sum_eng %>% 
  ggplot(aes(x = age_subject, y = mean, 
             colour = task, shape = task)) +
  geom_point() +
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd)) 

fig_custom <-
sum_eng %>%
  mutate(task = fct_recode(task,
                           "LDT" = "rt_lexdec",
                           "Naming" = "rt_naming"),
  age_subject = fct_recode(age_subject,
                           "Young" = "young",
                           "Old" = "old")) |> 
  ggplot(aes(x = age_subject, y = mean, 
             colour = task, shape = task)) +
  geom_point(position = position_dodge(0.3),
             size = 3) +
  geom_errorbar(aes(ymin=mean-sd,ymax=mean+sd),
                position = position_dodge(0.3), 
                width = .3) +
  geom_line(aes(group = task,
                linetype = task),
                position = position_dodge(0.3)) +
  theme_minimal() +
  labs(
    title = "Reaction times per group and task",
    x = "Age group",
    y = "Reaction time (ms)",
    colour = "Task",
    shape = "Task",
    linetype = "Task"
  ) +
  theme(axis.title = element_text(size = 12,
                                  face = "bold"),
        plot.title = element_text(size = 14),
        legend.title = element_text(face = "bold"))
```

```{r}
#| output-location: fragment
#| label: fig-custom
#| fig-cap: Customised plots to facilitation data communication.
#| echo: false
#| fig-width: 12
fig_custom + fig_dens_colour + fig_point_colour +
  plot_annotation(tag_levels = "A")
```

## Standardthemen

Zun√§chst wurde `theme_minimal()` zu jedem Plot hinzugef√ºgt, um das allgemeine Aussehen anzupassen. Es gibt eine Vielzahl von benutzerdefinierten Themen, wie `theme_bw()` oder `theme_classic()`. Probieren Sie sie aus.

```{r}
#| output-location: fragment
#| label: fig-themes
#| fig-cap: Preset themes
#| echo: false
#| fig-width: 12
#| fig-height: 3

  (fig_custom + theme_grey() +labs(title = "theme_grey() (default theme)"))  + 
  (fig_custom + theme_bw() +labs(title = "theme_bw()")) +
  (fig_custom + theme_minimal() +labs(title = "theme_minimal()")) + 
  (fig_custom + theme_classic() +labs(title = "theme_classic()")) +
  plot_layout(nrow = 1)
  
```

## theme()

Wir k√∂nnen auch einzelne Komponenten des Themas steuern, indem wir Anpassungen mit `theme()` hinzuf√ºgen. Zum Beispiel sehen wir in @fig-custom A, dass die Achsentitel fett gedruckt sind. Dies wurde durch Hinzuf√ºgen von `theme(axis.title = element_text(face = "bold))` erreicht, wobei `axis.title =` anzeigt, dass wir eine √Ñnderung an den Achsentiteln vornehmen wollen, `element_text()` zeigt an, dass es ihr Text ist, den wir √§ndern wollen, und `face = "bold"` zeigt an, dass wir den Text fett machen wollen. Dasselbe wurde f√ºr `legend.title =` gemacht, um den Titel der Legende fett zu machen. 

```{r}
#| output-location: fragment
#| label: fig-italics
#| fig-cap: Using theme()

fig_no_colour + theme_minimal() + 
  theme(
    axis.title = element_text(face = "italic")
    )
```


# Heutige Ziele üèÅ {.unnumbered .unlisted}

Wir haben gelernt, wie man...

- mehrteilige Plots erstellen ‚úÖ
- die Position von Geomen anzupassen ‚úÖ
- unsere Plots f√ºr eine bessere Datenkommunikation anpassen ‚úÖ

# Aufgaben

1. Mehrteilige Darstellung. Erzeugen von @fig-dodged und @fig-violin1 f√ºr `rt_naming` (anstelle von `rt_lexdec`). Drucken der Plots nebeneinander mit `patchwork`.

2. Beschriftungen. Benutzen Sie `labs()`, um Beschriftungen f√ºr den Titel, die x- und y-Achse und f√ºr die von Ihnen verwendete √Ñsthetik (Form, Farbe, etc.) hinzuzuf√ºgen, die in einer Legende resultieren. Dies sollte damit enden, dass der Titel der Legende auch einen eigenen Namen erh√§lt.

2. Anpassungen. F√ºgen Sie den beiden Diagrammen Anpassungen hinzu, indem Sie ein Standardthema w√§hlen, gefolgt von `theme()` mit Anpassungen f√ºr die Achsentitel, den Legendentitel und den Diagrammtitel. Sie k√∂nnen `face`, `size`, `colour`, `family` (d.h. Schriftart) √§ndern. Sie k√∂nnen `?theme` in der Konsole eingeben oder googeln, um einige Ideen zu bekommen. Wenn Sie sich nicht kreativ f√ºhlen, versuchen Sie einfach, eine der Anpassungen zu replizieren, die Sie in @fig-custom sehen

# Session Info {.unnumbered}

```{r}
#| eval: false
#| echo: false
RStudio.Version()$version
```


Hergestellt mit `r R.version.string` (`r R.version$nickname`) und RStudioversion 2023.3.0.386 (Cherry Blossom).

```{r}
print(sessionInfo(),locale = F)
```

# Literaturverzeichnis {.unlisted .unnumbered visibility="uncounted"}

::: {#refs custom-style="Bibliography"}
:::
